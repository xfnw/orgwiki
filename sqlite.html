<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-20 Wed 21:17 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sqlite</title>
<meta name="generator" content="Org Mode" />
<meta charset="UTF-8">
<style>
body {
font-family:monospace; font-size:12pt;
max-width: 700px; margin: 10px 20px;
}
@media only print {
body {
color:#000000; background-color:#ffffff;
}
}
@media only screen {
body {
color:#bfbfbf; background-color:#000000;
}
}
h1 { font-size:144%; }
h2,h3,h4,h5,h6 { font-size:120%; }
a {
text-decoration-style:solid;
}
@media only print {
a {
background-color:#ffffff;
color:#000000;
}
}
@media only screen {
a {
background-color:#112222;
color:#bfbfbf;
}
}
pre {
font-size:10.5pt;
max-width:80ch;
border: 1pt dotted #bfbfbf;
padding:1ch;
}
code {
border: 1pt dotted #bfbfbf;
padding: 0 0.15em;
}
@media only screen {
code {
background-color:#222211;
}
}
.example { white-space:pre-wrap; }
.src { white-space:pre-wrap; }
@media only screen {
.example { background-color:#222211; }
.src { background-color:#222211; }
}
blockquote {
border: 1pt solid #bfbfbf;
padding: 0 1ch;
}
@media only screen {
blockquote {
background-color: #111100;
}
}
.tag { float:right; }
.tag:before { content: "["; }
.tag:after { content: "]"; }
@media only screen {
.tag { background-color:#111100; }
.tag:before { background-color:#111100; }
.tag:after { background-color:#111100; }
}
.done { }
.done:before { content: "["; }
.done:after { content: "]"; }
@media only screen {
.done { background-color: #117711; }
}
.todo { }
.todo:before { content: "["; }
.todo:after { content: "]"; }
@media only screen {
.todo { background-color: #bb1111; }
}
@media only screen {
.DELAYED { background-color: #220077; }
.RERUN { background-color: #775511; }
}
.FIXME:before,.fixme:before { content: "[FIXME]Â "; float:left; }
@media only screen {
.FIXME,.fixme { background-color: #bb1111; }
}
.org-center { text-align:center; }
table { width:100%; border-collapse:collapse; }
table, th, td { vertical-align:top; }
img { max-width:100%;display:block;margin:auto;height:auto; }
.timestamp { }
@media only screen {
.timestamp { background-color: #221122; }
}
@media only screen {
:target { background-color: #222211; }
}
@media only print {
nav { display: none; }
}
.footpara { display: inline; }
</style>
<nav>
<a href="index.html">home</a> /
<a href="about.html">about</a> /
<a href="sitemap.html">sitemap</a> /
</nav>
</head>
<body>
<div id="content" class="content">
<h1 class="title">sqlite</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0000000">1. looking at tables</a></li>
<li><a href="#org0000001">2. output formatting</a></li>
<li><a href="#org0000002">3. foreign keys</a></li>
<li><a href="#org0000003">4. json</a>
<ul>
<li><a href="#org0000004">4.1. output</a></li>
<li><a href="#org0000005">4.2. input</a></li>
<li><a href="#org0000006">4.3. generated columns</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org0000000" class="outline-2">
<h2 id="org0000000"><span class="section-number-2">1.</span> looking at tables</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>.schema</code> and then optionally the table name will show the command to
create a table with the same schema. some people seem to say it will
be incorrect if the schema has been modified after the original table
creation, but this looks to not be true
</p>

<p>
<code>.tables</code> lists tables
</p>
</div>
</div>

<div id="outline-container-org0000001" class="outline-2">
<h2 id="org0000001"><span class="section-number-2">2.</span> output formatting</h2>
<div class="outline-text-2" id="text-2">
<p>
sqlite's default <code>|</code>-delimited output is mildly unreadable
</p>

<p>
<code>.headers on</code> will display headers
</p>

<p>
<code>.mode column</code> will display output in nice columns, you can also use
<code>box</code> to output in fancy unicode boxes
</p>
</div>
</div>

<div id="outline-container-org0000002" class="outline-2">
<h2 id="org0000002"><span class="section-number-2">3.</span> foreign keys</h2>
<div class="outline-text-2" id="text-3">
<p>
to enfore a dependency on another table, foreign keys can be used.
</p>

<pre class="example" id="org0000007">
CREATE TABLE example
( ...
, FOREIGN KEY(columnname) REFERENCES othertable(othercolumn)
);
</pre>
</div>
</div>

<div id="outline-container-org0000003" class="outline-2">
<h2 id="org0000003"><span class="section-number-2">4.</span> json</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org0000004" class="outline-3">
<h3 id="org0000004"><span class="section-number-3">4.1.</span> output</h3>
<div class="outline-text-3" id="text-4-1">
<pre class="example" id="org0000007">
.mode json
</pre>
<p>
will make sqlite output in json format
</p>
</div>
</div>

<div id="outline-container-org0000005" class="outline-3">
<h3 id="org0000005"><span class="section-number-3">4.2.</span> input</h3>
<div class="outline-text-3" id="text-4-2">
<pre class="example" id="org0000007">
INSERT INTO table (beep, boop) SELECT json_extract(value, '$.foo'),
json_extract(value, '$.bar') FROM json_each(readfile('/dev/stdin'));
</pre>
<p>
will take a list of json objects from stdin and put the values from
the 'foo' and 'bar' keys into the 'beep' and 'boop' columns.
</p>
</div>
</div>

<div id="outline-container-org0000006" class="outline-3">
<h3 id="org0000006"><span class="section-number-3">4.3.</span> generated columns</h3>
<div class="outline-text-3" id="text-4-3">
<p>
sqlite can have special columns with calculated values, called
<a href="https://www.sqlite.org/gencol.html">generated columns</a>. we can use them to derive column values from json.
</p>

<pre class="example" id="org0000007">
CREATE TABLE noises
( raw TEXT
, species AS (json_extract(raw, '$.species')) STORED
, noise AS (json_extract(raw, '$.noise')) STORED
);
INSERT INTO noises (raw) SELECT value FROM
json_each('[{"species":"wah","noise":"wah"},{"species":"fox","noise":"aaa"}]');
SELECT species,noise FROM noises;
+---------+-------+
| species | noise |
+---------+-------+
| wah     | wah   |
| fox     | aaa   |
+---------+-------+
</pre>

<p>
<code>STORED</code> means the data will be stored in the table rather than
calculated on the fly every time it is viewed, though sadly it still
cannot be a <code>PRIMARY KEY</code>.
</p>

<p>
to automatically create a simple table with generated columns for the
top level of a json object (it will not recurse), we can use jq and
awk:
</p>
<pre class="example" id="org0000007">
jq 'keys_unsorted[]' -r |
awk 'BEGIN {print "CREATE TABLE hmm";print "( raw TEXT"}
{print ",",$1,"TEXT AS (json_extract(raw, '"'"'$." $1 "'"'"'))"}
END {print ");"}'
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
